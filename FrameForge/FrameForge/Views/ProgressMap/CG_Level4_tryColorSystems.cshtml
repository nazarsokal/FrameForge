<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Досліди з моделями кольорів</title>
    <link rel="icon" href="data:,">
    <style>
        body {
            background-color: #f0f0f0;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            padding: 20px;
            font-family: Arial, sans-serif;
        }
        h1 {
            font-size: 2em;
            font-weight: bold;
            margin-bottom: 20px;
        }
        .container {
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
            width: 100%;
            max-width: 1200px;
        }
        .input-section {
            margin-bottom: 20px;
        }
        .input-section label {
            display: block;
            font-size: 0.9em;
            color: #333;
        }
        .input-section input[type="file"] {
            margin-top: 5px;
            width: 100%;
        }
        .canvas-section {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        .canvas-section h2 {
            font-size: 1.2em;
            font-weight: bold;
        }
        canvas {
            border: 1px solid #ccc;
        }
        .button-section {
            margin-top: 20px;
            display: flex;
            gap: 10px;
        }
        .saturation-section {
            margin-top: 20px;
        }
        .saturation-section label {
            font-size: 0.9em;
            color: #333;
        }
        .saturation-section input[type="range"] {
            width: 100%;
            margin-top: 5px;
        }
        button {
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            color: white;
            cursor: pointer;
        }
        button:nth-child(1), button:nth-child(2) {
            background-color: #3b82f6;
        }
        button:nth-child(1):hover, button:nth-child(2):hover {
            background-color: #2563eb;
        }
        button:nth-child(3), button:nth-child(4) {
            background-color: #8b5cf6;
        }
        button:nth-child(3):hover, button:nth-child(4):hover {
            background-color: #7c3aed;
        }
        button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }
        .info-section {
            margin-top: 20px;
        }
        .info-section h2 {
            font-size: 1.2em;
            font-weight: bold;
        }
        .info-section p {
            font-size: 0.9em;
        }
        .instructions {
            font-size: 0.9em;
            color: #555;
            margin-bottom: 10px;
        }
    </style>
</head>
<body>
    <h1>Досліди з моделями кольорів</h1>
    <div class="container">
        <div class="input-section">
            <label>Завантажити зображення:</label>
            <input type="file" id="imageInput" accept="image/*">
        </div>
        <div class="instructions">
            <p>Щоб виділити фрагмент, затисніть ліву кнопку миші на обробленому зображенні та протягніть. Зміна насиченості застосовуватиметься лише до виділеної області.</p>
        </div>
        <div class="canvas-section">
            <div>
                <h2>Оригінальне зображення</h2>
                <canvas id="originalCanvas"></canvas>
            </div>
            <div>
                <h2>Оброблене зображення</h2>
                <canvas id="processedCanvas"></canvas>
            </div>
        </div>
        <div class="button-section">
            <button id="convertToLab">RGB → Lab</button>
            <button id="convertToRGB" disabled>Lab → RGB</button>
            <button id="saveImage">Зберегти зображення</button>
            <button id="clearSelection">Очистити виділення</button>
        </div>
        <div class="saturation-section">
            <label>Регулювання насиченості синього (0-1):</label>
            <input type="range" id="saturationRange" min="0" max="1" value="0.5" step="0.01">
        </div>
        <div class="info-section">
            <h2>Інформація про піксель</h2>
            <p id="pixelInfo"></p>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const imageInput = document.getElementById('imageInput');
            const originalCanvas = document.getElementById('originalCanvas');
            const processedCanvas = document.getElementById('processedCanvas');
            const convertToLabBtn = document.getElementById('convertToLab');
            const convertToRGBBtn = document.getElementById('convertToRGB');
            const saveImageBtn = document.getElementById('saveImage');
            const clearSelectionBtn = document.getElementById('clearSelection');
            const saturationRange = document.getElementById('saturationRange');
            const pixelInfo = document.getElementById('pixelInfo');

            let originalImageData, processedImageData, img;
            let labData = [];
            let isLabConverted = false;
            let isSelecting = false;
            let selection = null;

            function rgbToXyz(rgb) {
                let r = rgb.r, g = rgb.g, b = rgb.b;
                r = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92;
                g = g > 0.04045 ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92;
                b = b > 0.04045 ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92;

                r *= 100;
                g *= 100;
                b *= 100;

                const x = r * 0.4124 + g * 0.3576 + b * 0.1805;
                const y = r * 0.2126 + g * 0.7152 + b * 0.0722;
                const z = r * 0.0193 + g * 0.1192 + b * 0.9505;

                return { x, y, z };
            }

            function xyzToLab(xyz) {
                const refX = 95.047, refY = 100.0, refZ = 108.883;
                let x = xyz.x / refX;
                let y = xyz.y / refY;
                let z = xyz.z / refZ;

                x = x > 0.008856 ? Math.pow(x, 1/3) : (7.787 * x) + (16/116);
                y = y > 0.008856 ? Math.pow(y, 1/3) : (7.787 * y) + (16/116);
                z = z > 0.008856 ? Math.pow(z, 1/3) : (7.787 * z) + (16/116);

                const l = (116 * y) - 16;
                const a = 500 * (x - y);
                const b = 200 * (y - z);

                return { l: Math.min(100, Math.max(0, l)), a, b };
            }

            function labToXyz(lab) {
                const refX = 95.047, refY = 100.0, refZ = 108.883;
                let y = (lab.l + 16) / 116;
                let x = lab.a / 500 + y;
                let z = y - lab.b / 200;

                const y2 = Math.pow(y, 3);
                y = y2 > 0.008856 ? y2 : (y - 16 / 116) / 7.787;
                const x2 = Math.pow(x, 3);
                x = x2 > 0.008856 ? x2 : (x - 16 / 116) / 7.787;
                const z2 = Math.pow(z, 3);
                z = z2 > 0.008856 ? z2 : (z - 16 / 116) / 7.787;

                x *= refX;
                y *= refY;
                z *= refZ;

                return { x, y, z };
            }

            function xyzToRgb(xyz) {
                let x = xyz.x / 100;
                let y = xyz.y / 100;
                let z = xyz.z / 100;

                let r = x * 3.2406 + y * -1.5372 + z * -0.4986;
                let g = x * -0.9689 + y * 1.8758 + z * 0.0415;
                let b = x * 0.0557 + y * -0.2040 + z * 1.0570;

                r = r > 0.0031308 ? 1.055 * Math.pow(r, 1/2.4) - 0.055 : 12.92 * r;
                g = g > 0.0031308 ? 1.055 * Math.pow(g, 1/2.4) - 0.055 : 12.92 * g;
                b = b > 0.0031308 ? 1.055 * Math.pow(b, 1/2.4) - 0.055 : 12.92 * b;

                r = Math.min(Math.max(r, 0), 1);
                g = Math.min(Math.max(g, 0), 1);
                b = Math.min(Math.max(b, 0), 1);

                return { r, g, b };
            }

            function rgbToLab(rgb) {
                const xyz = rgbToXyz(rgb);
                const lab = xyzToLab(xyz);
                lab.a = Math.min(127, Math.max(-128, lab.a));
                lab.b = Math.min(127, Math.max(-128, lab.b));
                return lab;
            }

            function labToRgb(lab) {
                const l = Math.min(Math.max(lab.l, 0), 100);
                const a = Math.min(Math.max(lab.a, -128), 127);
                const b = Math.min(Math.max(lab.b, -128), 127);

                const xyz = labToXyz({ l, a, b });
                return xyzToRgb(xyz);
            }

            function rgbToHsv(rgb) {
                let r = rgb.r, g = rgb.g, b = rgb.b;
                let max = Math.max(r, g, b), min = Math.min(r, g, b);
                let h, s, v = max;

                let d = max - min;
                s = max === 0 ? 0 : d / max;

                if (max === min) {
                    h = 0; // achromatic
                } else {
                    switch (max) {
                        case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                        case g: h = (b - r) / d + 2; break;
                        case b: h = (r - g) / d + 4; break;
                    }
                    h /= 6;
                }

                h = h * 360; // Градуси [0, 360]
                s = s * 100; // Відсотки [0, 100]
                v = v * 100; // Відсотки [0, 100]

                return { h, s, v };
            }

            function hsvToRgb(hsv) {
                let h = hsv.h / 360, s = hsv.s / 100, v = hsv.v / 100;
                let r, g, b;

                let i = Math.floor(h * 6);
                let f = h * 6 - i;
                let p = v * (1 - s);
                let q = v * (1 - f * s);
                let t = v * (1 - (1 - f) * s);

                switch (i % 6) {
                    case 0: r = v, g = t, b = p; break;
                    case 1: r = q, g = v, b = p; break;
                    case 2: r = p, g = v, b = t; break;
                    case 3: r = p, g = q, b = v; break;
                    case 4: r = t, g = p, b = v; break;
                    case 5: r = v, g = p, b = q; break;
                }

                return { r, g, b };
            }

            function isDarkBlue(rgb) {
                const [r, g, b] = rgb;
                return r < 150 && g < 150 && b > 50 && b <= 255; // Розширені межі
            }

            function drawSelection() {
                if (!processedImageData || !selection) return;
                const ctx = processedCanvas.getContext('2d', { willReadFrequently: true });
                ctx.putImageData(processedImageData, 0, 0);
                ctx.strokeStyle = 'red';
                ctx.lineWidth = 2;
                ctx.strokeRect(
                    selection.startX,
                    selection.startY,
                    selection.endX - selection.startX,
                    selection.endY - selection.startY
                );
            }

            imageInput.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (file) {
                    img = new Image();
                    img.onload = () => {
                        originalCanvas.width = 500;
                        originalCanvas.height = 500;
                        processedCanvas.width = 500;
                        processedCanvas.height = 500;
                        const ctx = originalCanvas.getContext('2d', { willReadFrequently: true });

                        const canvasRatio = 500 / 500;
                        const imgRatio = img.width / img.height;
                        let drawWidth, drawHeight;

                        if (imgRatio > canvasRatio) {
                            drawWidth = 500;
                            drawHeight = 500 / imgRatio;
                        } else {
                            drawHeight = 500;
                            drawWidth = 500 * imgRatio;
                        }

                        const offsetX = (500 - drawWidth) / 2;
                        const offsetY = (500 - drawHeight) / 2;

                        ctx.fillStyle = 'white';
                        ctx.fillRect(0, 0, 500, 500);
                        ctx.drawImage(img, offsetX, offsetY, drawWidth, drawHeight);
                        originalImageData = ctx.getImageData(0, 0, 500, 500);
                        processedImageData = ctx.createImageData(500, 500);
                        processedImageData.data.set(originalImageData.data);
                        processedCanvas.getContext('2d', { willReadFrequently: true }).putImageData(processedImageData, 0, 0);

                        isLabConverted = false;
                        labData = [];
                        selection = null;
                        convertToRGBBtn.disabled = true;
                    };
                    img.src = URL.createObjectURL(file);
                }
            });

            convertToLabBtn.addEventListener('click', () => {
                if (!originalImageData) return;
                processedImageData = originalCanvas.getContext('2d', { willReadFrequently: true }).getImageData(0, 0, 500, 500);
                const data = processedImageData.data;
                labData = [];
                for (let i = 0; i < data.length; i += 4) {
                    const rgb = { r: data[i] / 255, g: data[i + 1] / 255, b: data[i + 2] / 255 };
                    const lab = rgbToLab(rgb);
                    labData.push(lab);
                    data[i + 3] = 255; // Альфа-канал
                }
                processedCanvas.getContext('2d', { willReadFrequently: true }).putImageData(processedImageData, 0, 0);
                drawSelection();
                checkColorIntegrity();
                isLabConverted = true;
                convertToRGBBtn.disabled = false;
            });

            convertToRGBBtn.addEventListener('click', () => {
                if (!processedImageData || !isLabConverted || labData.length === 0) return;
                const newImageData = originalCanvas.getContext('2d', { willReadFrequently: true }).createImageData(500, 500);
                const newData = newImageData.data;
                for (let i = 0; i < newData.length; i += 4) {
                    const idx = i / 4;
                    const lab = labData[idx];
                    const rgb = labToRgb(lab);
                    newData[i] = Math.min(255, Math.max(0, rgb.r * 255));
                    newData[i + 1] = Math.min(255, Math.max(0, rgb.g * 255));
                    newData[i + 2] = Math.min(255, Math.max(0, rgb.b * 255));
                    newData[i + 3] = 255;
                }
                processedImageData = newImageData;
                processedCanvas.getContext('2d', { willReadFrequently: true }).putImageData(processedImageData, 0, 0);
                drawSelection();
                checkColorIntegrity();
                isLabConverted = false;
                labData = [];
                convertToRGBBtn.disabled = true;
            });

            saturationRange.addEventListener('input', () => {
                if (!originalImageData) return;
                processedImageData = originalCanvas.getContext('2d', { willReadFrequently: true }).getImageData(0, 0, 500, 500);
                const data = processedImageData.data;
                const saturationFactor = saturationRange.value / 0.5;
                labData = [];

                let minX, maxX, minY, maxY;
                if (selection) {
                    minX = Math.min(selection.startX, selection.endX);
                    maxX = Math.max(selection.startX, selection.endX);
                    minY = Math.min(selection.startY, selection.endY);
                    maxY = Math.max(selection.startY, selection.endY);
                    minX = Math.max(0, Math.floor(minX));
                    maxX = Math.min(500, Math.ceil(maxX));
                    minY = Math.max(0, Math.floor(minY));
                    maxY = Math.min(500, Math.ceil(maxY));
                } else {
                    minX = 0;
                    maxX = 500;
                    minY = 0;
                    maxY = 500;
                }

                let modifiedPixels = 0;

                for (let y = 0; y < 500; y++) {
                    for (let x = 0; x < 500; x++) {
                        const i = (y * 500 + x) * 4;
                        const rgb = { r: data[i] / 255, g: data[i + 1] / 255, b: data[i + 2] / 255 };
                        const hsv = rgbToHsv(rgb);
                        labData.push(hsv);
                        if (x >= minX && x < maxX && y >= minY && y < maxY && isDarkBlue([data[i], data[i + 1], data[i + 2]])) {
                            let modifiedHsv = { ...hsv };
                            modifiedHsv.s = Math.max(0, hsv.s * saturationFactor); // Без обмеження 100
                            const modifiedRgb = hsvToRgb(modifiedHsv);
                            data[i] = Math.min(255, Math.max(0, modifiedRgb.r * 255));
                            data[i + 1] = Math.min(255, Math.max(0, modifiedRgb.g * 255));
                            data[i + 2] = Math.min(255, Math.max(0, modifiedRgb.b * 255));
                            modifiedPixels++;
                        }
                    }
                }
                console.log(`Змінено пікселів: ${modifiedPixels}, Saturation Factor: ${saturationFactor}`);
                processedCanvas.getContext('2d', { willReadFrequently: true }).putImageData(processedImageData, 0, 0);
                drawSelection();
                isLabConverted = false;
                convertToRGBBtn.disabled = true;
            });

            function checkColorIntegrity() {
                const originalData = originalImageData.data;
                const processedData = processedImageData.data;
                let mismatchedPixels = 0;
                const totalPixels = originalData.length / 4;

                for (let i = 0; i < originalData.length; i += 4) {
                    if (
                        Math.abs(originalData[i] - processedData[i]) > 1 ||
                        Math.abs(originalData[i + 1] - processedData[i + 1]) > 1 ||
                        Math.abs(originalData[i + 2] - processedData[i + 2]) > 1
                    ) {
                        mismatchedPixels++;
                    }
                }

                const mismatchPercentage = (mismatchedPixels / totalPixels) * 100;
                const isIdentical = mismatchedPixels === 0;
                pixelInfo.textContent += `\nЗображення ${isIdentical ? 'не зазнало' : 'зазнало'} змін кольорів. Похибка: ${mismatchPercentage.toFixed(2)}% пікселів не співпадають.`;
            }

            processedCanvas.addEventListener('mousedown', (e) => {
                const rect = processedCanvas.getBoundingClientRect();
                selection = {
                    startX: e.clientX - rect.left,
                    startY: e.clientY - rect.top,
                    endX: e.clientX - rect.left,
                    endY: e.clientY - rect.top
                };
                isSelecting = true;
            });

            processedCanvas.addEventListener('mousemove', (e) => {
                if (isSelecting && processedImageData) {
                    const rect = processedCanvas.getBoundingClientRect();
                    selection.endX = Math.min(500, Math.max(0, e.clientX - rect.left));
                    selection.endY = Math.min(500, Math.max(0, e.clientY - rect.top));
                    drawSelection();
                }
                if (!processedImageData) return;
                const rect = processedCanvas.getBoundingClientRect();
                const x = Math.floor(e.clientX - rect.left);
                const y = Math.floor(e.clientY - rect.top);
                if (x >= 0 && x < 500 && y >= 0 && y < 500) {
                    const i = (y * 500 + x) * 4;
                    const idx = i / 4;
                    if (isLabConverted && labData[idx]) {
                        const lab = labData[idx];
                        pixelInfo.textContent = `Піксель (${x}, ${y}): Lab(${lab.l.toFixed(2)}, ${lab.a.toFixed(2)}, ${lab.b.toFixed(2)})`;
                    } else {
                        const rgb = {
                            r: processedImageData.data[i] / 255,
                            g: processedImageData.data[i + 1] / 255,
                            b: processedImageData.data[i + 2] / 255
                        };
                        const lab = rgbToLab(rgb);
                        pixelInfo.textContent = `Піксель (${x}, ${y}): RGB(${Math.round(rgb.r * 255)}, ${Math.round(rgb.g * 255)}, ${Math.round(rgb.b * 255)}) | Lab(${lab.l.toFixed(2)}, ${lab.a.toFixed(2)}, ${lab.b.toFixed(2)})`;
                    }
                }
            });

            processedCanvas.addEventListener('mouseup', () => {
                isSelecting = false;
                drawSelection();
            });

            clearSelectionBtn.addEventListener('click', () => {
                selection = null;
                if (processedImageData) {
                    processedCanvas.getContext('2d', { willReadFrequently: true }).putImageData(processedImageData, 0, 0);
                }
            });

            saveImageBtn.addEventListener('click', () => {
                if (!processedCanvas) return;
                const link = document.createElement('a');
                link.download = 'processed_image.png';
                link.href = processedCanvas.toDataURL('image/png');
                link.click();
            });
        });
    </script>
</body>
</html>